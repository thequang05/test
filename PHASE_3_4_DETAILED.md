# üéæ H∆Ø·ªöNG D·∫™N CHI TI·∫æT PHASE 3 & 4 - TENNIS ANALYSIS

---

## üß≠ M·ª§C TI√äU

- Phase 3: Ph√°t hi·ªán s√¢n tennis (14 keypoints), t·∫°o h·ªá tr·ª•c mini-court, √°nh x·∫° pixel ‚Üí m√©t
- Phase 4: T√≠nh to√°n th·ªëng k√™ (t·ªëc ƒë·ªô b√≥ng/ng∆∞·ªùi, s·ªë c√∫ ƒë√°nh), v·∫Ω overlay v√† xu·∫•t video ho√†n ch·ªânh

---

## üìã PHASE 3: COURT DETECTION & MINI COURT

### 1) File: `court_line_detector/court_line_detector.py`
```python
import torch
import cv2
import numpy as np

class CourtLineDetector:
    def __init__(self, model_path: str):
        """
        Kh·ªüi t·∫°o ResNet50/Keypoint model ƒë·ªÉ d·ª± ƒëo√°n 14 keypoints s√¢n tennis

        Args:
            model_path (str): ƒê∆∞·ªùng d·∫´n model keypoints (e.g. models/keypoints_model.pth)
        """
        # TODO: Implement
        # 1. Load model, set eval mode
        # 2. T·∫°o device (cuda/cpu) v√† ƒë·∫©y model l√™n device
        pass

    def preprocess(self, frame):
        """Ti·ªÅn x·ª≠ l√Ω frame (resize/normalize) ‚Üí tensor cho model."""
        # TODO: Implement
        pass

    def predict_keypoints(self, frame):
        """
        D·ª± ƒëo√°n 14 keypoints tr√™n 1 frame

        Returns:
            list[tuple]: [(x1,y1), ..., (x14,y14)] theo th·ª© t·ª± c·ªë ƒë·ªãnh
        """
        # TODO: Implement
        # 1. Ti·ªÅn x·ª≠ l√Ω ‚Üí tensor
        # 2. model.forward ‚Üí keypoints (normalized)
        # 3. Convert v·ªÅ pixel coordinates theo k√≠ch th∆∞·ªõc frame
        pass

    def draw_keypoints(self, frame, keypoints, color=(0,255,255)):
        """V·∫Ω keypoints l√™n frame ƒë·ªÉ debug/quan s√°t."""
        # TODO: Implement
        pass
```

### 2) File: `mini_court/mini_court.py`
```python
import numpy as np
import cv2
from typing import List, Tuple

class MiniCourt:
    def __init__(self, court_keypoints: List[Tuple[int,int]], frame_shape):
        """
        Kh·ªüi t·∫°o h·ªá t·ªça ƒë·ªô mini-court d·ª±a tr√™n 14 keypoints v√† k√≠ch th∆∞·ªõc frame ƒë·∫ßu ti√™n
        - T√≠nh homography ho·∫∑c projective transform t·ª´ s√¢n th·∫≠t ‚Üí ·∫£nh
        - L∆∞u c√°c ma tr·∫≠n bi·∫øn ƒë·ªïi ƒë·ªÉ d√πng sau
        """
        # TODO: Implement
        # 1. ƒê·ªãnh nghƒ©a c√°c ƒëi·ªÉm chu·∫©n (th·∫ø gi·ªõi th·ª±c, m√©t) cho 14 keypoints
        # 2. T√≠nh H (homography) gi·ªØa court_real ‚Üî court_pixel
        pass

    def pixel_to_meters(self, pixel_point: Tuple[float,float]) -> Tuple[float,float]:
        """Chuy·ªÉn 1 ƒëi·ªÉm pixel tr√™n ·∫£nh sang t·ªça ƒë·ªô m√©t tr√™n s√¢n."""
        # TODO: Implement (d·ª±a tr√™n homography + t·ª∑ l·ªá k√≠ch th∆∞·ªõc s√¢n)
        pass

    def pixels_to_meters_batch(self, points: List[Tuple[float,float]]):
        # TODO: Vectorize chuy·ªÉn ƒë·ªïi h√†ng lo·∫°t ƒëi·ªÉm
        pass

    def draw_mini_court(self, canvas_size=(400, 200)):
        """V·∫Ω mini-court chu·∫©n (2D top-down) ƒë·ªÉ overlay v√†o video."""
        # TODO: Implement
        pass

    def draw_positions(self, mini_court_img, player_positions_m, ball_positions_m):
        """V·∫Ω v·ªã tr√≠ ng∆∞·ªùi ch∆°i v√† b√≥ng (ƒë∆°n v·ªã m√©t, chi·∫øu l√™n mini-court)."""
        # TODO: Implement
        pass
```

### 3) D·ªØ li·ªáu h√¨nh h·ªçc s√¢n (g·ª£i √Ω)
- S·ª≠ d·ª•ng c√°c h·∫±ng s·ªë trong `constants/__init__.py` (SINGLE_LINE_WIDTH, DOUBLE_LINE_WIDTH, HALF_COURT_LINE_HEIGHT, ...)
- X√°c ƒë·ªãnh h·ªá tr·ª•c: g·ªëc t·∫°i t√¢m s√¢n, tr·ª•c X theo b·ªÅ ngang, tr·ª•c Y theo d·ªçc s√¢n
- Map 14 keypoints th·ª±c ‚Üí th·ª© t·ª± model tr·∫£ v·ªÅ ƒë·ªÉ t√≠nh homography ·ªïn ƒë·ªãnh

### 4) Test nhanh Phase 3
```python
# Trong 1 script t·∫°m th·ªùi (v√≠ d·ª•: test_phase_3.py)
from court_line_detector.court_line_detector import CourtLineDetector
from mini_court.mini_court import MiniCourt
from utils.video_utils import read_video

frames = read_video('input_videos/input_video.mp4')
clf = CourtLineDetector('models/keypoints_model.pth')
kp = clf.predict_keypoints(frames[0])
mini = MiniCourt(kp, frame_shape=frames[0].shape)
mini_img = mini.draw_mini_court()
# L∆∞u/xem mini_img ƒë·ªÉ x√°c nh·∫≠n
```

---

## üìä PHASE 4: TRACKING, METRICS & VISUALIZATION

### 1) T√≠nh to√°n positions v√† t·ªëc ƒë·ªô ng∆∞·ªùi ch∆°i
```python
# G·ª£i √Ω trong trackers/player_tracker.py
from utils.bbox_utils import get_center_of_bbox
from utils.conversions import measure_distance, calculate_speed_mps, convert_mps_to_kmh

def calculate_player_speed(self, player_detections, fps=24):
    """
    Input: list theo frame, m·ªói frame l√† dict {player_id: bbox}
    Output: dict {frame_index: {player_id: speed_kmh}}
    """
    # TODO: Implement
    # 1. L·∫•y t√¢m bbox qua c√°c frame ‚Üí qu√£ng ƒë∆∞·ªùng pixel
    # 2. Œît = 1/fps ‚Üí m/s ‚Üí km/h
    pass
```

### 2) Interpolate b√≥ng, ph√°t hi·ªán ball hits, t√≠nh t·ªëc ƒë·ªô b√≥ng
```python
# G·ª£i √Ω trong trackers/ball_tracker.py
def interpolate_ball_positions(self, ball_positions):
    # TODO: pandas.DataFrame.interpolate + bfill
    pass

def get_ball_shot_frames(self, ball_positions):
    # TODO: ph√°t hi·ªán khi h∆∞·ªõng chuy·ªÉn ƒë·ªông theo tr·ª•c d·ªçc ƒë·ªïi d·∫•u r√µ r·ªát
    pass

def calculate_ball_speed(self, ball_positions, ball_shot_frames, fps=24):
    # TODO: t·ªëc ƒë·ªô gi·ªØa c√°c kho·∫£ng shot, ƒë·ªïi ra km/h
    pass
```

### 3) Visualization (Player Stats Drawer)
```python
# File: utils/player_stats_drawer_utils.py (g·ª£i √Ω template)
import cv2
import numpy as np

def draw_player_stats(output_video_frames, player_stats_df,
                      panel_width=350, panel_height=230,
                      margin_right=400, margin_bottom=500):
    """
    V·∫Ω b·∫£ng th·ªëng k√™ l√™n t·ª´ng frame d·ª±a v√†o DataFrame theo frame index.

    Y√™u c·∫ßu c·ªôt:
      - 'player_1_last_shot_speed', 'player_2_last_shot_speed'
      - 'player_1_last_player_speed', 'player_2_last_player_speed'
      - 'player_1_average_shot_speed', 'player_2_average_shot_speed'
      - 'player_1_average_player_speed', 'player_2_average_player_speed'
    """
    for index, row in player_stats_df.iterrows():
        frame = output_video_frames[index]

        start_x = frame.shape[1] - margin_right
        start_y = frame.shape[0] - margin_bottom
        end_x = start_x + panel_width
        end_y = start_y + panel_height

        overlay = frame.copy()
        cv2.rectangle(overlay, (start_x, start_y), (end_x, end_y), (0, 0, 0), -1)
        cv2.addWeighted(overlay, 0.5, frame, 0.5, 0, frame)

        def put(txt, xy, scale=0.5, thick=1):
            cv2.putText(frame, txt, xy, cv2.FONT_HERSHEY_SIMPLEX, scale, (255,255,255), thick)

        put("     Player 1     Player 2", (start_x+80, start_y+30), 0.6, 2)
        put("Shot Speed", (start_x+10, start_y+80), 0.45, 1)
        put(f"{row['player_1_last_shot_speed']:.1f} km/h    {row['player_2_last_shot_speed']:.1f} km/h",
            (start_x+130, start_y+80), 0.5, 2)

        put("Player Speed", (start_x+10, start_y+120), 0.45, 1)
        put(f"{row['player_1_last_player_speed']:.1f} km/h    {row['player_2_last_player_speed']:.1f} km/h",
            (start_x+130, start_y+120), 0.5, 2)

        put("avg. S. Speed", (start_x+10, start_y+160), 0.45, 1)
        put(f"{row['player_1_average_shot_speed']:.1f} km/h    {row['player_2_average_shot_speed']:.1f} km/h",
            (start_x+130, start_y+160), 0.5, 2)

        put("avg. P. Speed", (start_x+10, start_y+200), 0.45, 1)
        put(f"{row['player_1_average_player_speed']:.1f} km/h    {row['player_2_average_player_speed']:.1f} km/h",
            (start_x+130, start_y+200), 0.5, 2)

        output_video_frames[index] = frame

    return output_video_frames
```

### 4) √Ånh x·∫° pixel ‚Üí m√©t b·∫±ng `MiniCourt`
```python
# Trong main.py
mini_court = MiniCourt(court_keypoints, frame_shape=video_frames[0].shape)

# V·ªã tr√≠ ng∆∞·ªùi ch∆°i/ b√≥ng theo pixel ‚Üí m√©t
player_positions_m = {}
for frame_idx, det in enumerate(filtered_player_detections):
    player_positions_m[frame_idx] = {}
    for pid, bbox in det.items():
        cx, cy = get_center_of_bbox(bbox)
        player_positions_m[frame_idx][pid] = mini_court.pixel_to_meters((cx, cy))

ball_positions_m = []
for frame_idx, det in enumerate(ball_detections):
    if det:
        (x1,y1,x2,y2) = list(det.values())[0]
        cx, cy = (x1+x2)/2, (y1+y2)/2
        ball_positions_m.append(mini_court.pixel_to_meters((cx, cy)))
    else:
        ball_positions_m.append(None)
```

### 5) V·∫Ω overlay th·ªëng k√™ v√† mini-court
```python
# G·ª£i √Ω overlay trong utils/player_stats_drawer_utils.py ho·∫∑c ngay trong main.py
def draw_overlay(frame, stats_dict):
    # TODO: V·∫Ω text: t·ªëc ƒë·ªô P1/P2, t·ªëc ƒë·ªô b√≥ng, s·ªë c√∫ ƒë√°nh, v.v.
    pass

# V·∫Ω mini-court thu nh·ªè ·ªü g√≥c video
mini_img = mini_court.draw_mini_court()
mini_img = mini_court.draw_positions(mini_img, player_positions_m.get(i, {}), ball_positions_m[i])
# TODO: paste mini_img l√™n frame (ROI) b·∫±ng OpenCV
```

### 6) T√≠ch h·ª£p to√†n b·ªô trong `main.py`
Lu·ªìng khuy·∫øn ngh·ªã:
1. ƒê·ªçc video ‚Üí `video_frames`
2. Ph√°t hi·ªán keypoints s√¢n frame ƒë·∫ßu ‚Üí `court_keypoints`
3. Kh·ªüi t·∫°o `MiniCourt`
4. Detect players/ball (stub ho·∫∑c model th·∫≠t)
5. Ch·ªçn v√† l·ªçc 2 ng∆∞·ªùi ch∆°i ch√≠nh ‚Üí `filtered_player_detections`
6. Interpolate b√≥ng ‚Üí `ball_positions_interpolated`
7. T√≠nh shot frames + t·ªëc ƒë·ªô b√≥ng ‚Üí `ball_speeds`
8. √Ånh x·∫° pixel ‚Üí m√©t ‚Üí t·∫°o `player_positions_m`, `ball_positions_m`
9. V·∫Ω overlay + mini-court theo t·ª´ng frame
10. L∆∞u video output

### 7) Test nhanh Phase 4
```python
# Trong 1 script t·∫°m th·ªùi (v√≠ d·ª•: test_phase_4.py)
# Gi·∫£ s·ª≠ ƒë√£ c√≥ detections t·ª´ stub
from trackers.player_tracker import PlayerTracker
from trackers.ball_tracker import BallTracker

# TODO: T·∫°o d·ªØ li·ªáu gi·∫£ ho·∫∑c d√πng tracker_stubs/*.pkl ƒë·ªÉ test
# - T√≠nh velocity cho ng∆∞·ªùi ch∆°i
# - Ph√°t hi·ªán ball hits v√† t√≠nh t·ªëc ƒë·ªô b√≥ng
# - V·∫Ω overlay demo l√™n v√†i frame v√† ki·ªÉm tra tr·ª±c quan
```

---

## üß™ TESTING PHASE 3 & 4

### File: `test_phase_3_4.py`
```python
import sys
sys.path.append('.')

def test_court_and_minicourt():
    # TODO: Load 1 frame ‚Üí predict 14 keypoints ‚Üí kh·ªüi t·∫°o MiniCourt
    # Ki·ªÉm tra homography v√† v·∫Ω mini-court
    pass

def test_metrics_pipeline():
    # TODO: D√πng stubs ƒë·ªÉ t√≠nh t·ªëc ƒë·ªô ng∆∞·ªùi ch∆°i v√† b√≥ng ‚Üí ki·ªÉm tra gi√° tr·ªã h·ª£p l√Ω
    pass

if __name__ == "__main__":
    print("Testing Phase 3 & 4...")
    test_court_and_minicourt()
    test_metrics_pipeline()
    print("Phase 3 & 4 testing completed!")
```

---

## ‚úÖ CHECKLIST PHASE 3 & 4

### Phase 3 - Court Detection & Mini-Court
- [ ] Ho√†n thi·ªán `CourtLineDetector.predict_keypoints()`
- [ ] V·∫Ω `draw_keypoints()` ƒë·ªÉ debug
- [ ] X√°c ƒë·ªãnh 14 keypoints th·ª±c (th·ª© t·ª± ·ªïn ƒë·ªãnh)
- [ ] T√≠nh homography trong `MiniCourt`
- [ ] Vi·∫øt `pixel_to_meters()` v√† batch convert
- [ ] V·∫Ω `draw_mini_court()` v√† `draw_positions()`

### Phase 4 - Tracking, Metrics, Visualization
- [ ] T√≠nh t·ªëc ƒë·ªô ng∆∞·ªùi ch∆°i (px ‚Üí m/s ‚Üí km/h)
- [ ] Interpolate b√≥ng, ph√°t hi·ªán ball hits
- [ ] T√≠nh t·ªëc ƒë·ªô b√≥ng gi·ªØa c√°c l·∫ßn ƒë√°nh
- [ ] √Ånh x·∫° t·∫•t c·∫£ positions sang m√©t
- [ ] V·∫Ω overlay: t·ªëc ƒë·ªô P1/P2, t·ªëc ƒë·ªô b√≥ng, s·ªë c√∫ ƒë√°nh
- [ ] V·∫Ω mini-court overlay l√™n video
- [ ] L∆∞u video output ho√†n ch·ªânh

### M·ª•c ti√™u sau Phase 3 & 4
- ‚úÖ Ph√°t hi·ªán s√¢n v√† t·∫°o h·ªá t·ªça ƒë·ªô chu·∫©n
- ‚úÖ Chuy·ªÉn ƒë·ªïi v·ªØng v√†ng gi·ªØa pixel ‚Üî m√©t
- ‚úÖ T√≠nh c√°c th·ªëng k√™ ch√≠nh x√°c v√† tr·ª±c quan
- ‚úÖ Video output c√≥ overlay ƒë·∫ßy ƒë·ªß, mini-court r√µ r√†ng

---

## üí° L∆ØU √ù & M·∫∏O TH·ª∞C T·∫æ

- ∆Øu ti√™n d√πng stub ƒë·ªÉ ph√°t tri·ªÉn nhanh logic Phase 3-4, sau ƒë√≥ b·∫≠t models th·∫≠t
- ƒê·ªìng b·ªô th·ª© t·ª± 14 keypoints gi·ªØa model v√† logic homography ƒë·ªÉ tr√°nh sai l·ªách
- L·ªçc outlier tr∆∞·ªõc khi t√≠nh t·ªëc ƒë·ªô (median filter ho·∫∑c smoothing ƒë∆°n gi·∫£n)
- Kh√≥a FPS c·ªë ƒë·ªãnh khi l∆∞u video ƒë·ªÉ ph√©p t√≠nh t·ªëc ƒë·ªô ·ªïn ƒë·ªãnh
- Ghi log gi√° tr·ªã t·ªëc ƒë·ªô trung b√¨nh/t·ªëi ƒëa ƒë·ªÉ sanity-check

---

## üìé THAM CHI·∫æU LI√äN QUAN

- `constants/__init__.py`: K√≠ch th∆∞·ªõc s√¢n th·∫≠t
- `mini_court/mini_court.py`: Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô
- `court_line_detector/court_line_detector.py`: Keypoints detection
- `trackers/player_tracker.py`, `trackers/ball_tracker.py`: Detections & metrics
- `utils/video_utils.py`, `utils/bbox_utils.py`, `utils/conversions.py`: H·ªó tr·ª£ c∆° b·∫£n

"""
B·∫°n c√≥ th·ªÉ vi·∫øt code theo c√°c template TODO ·ªü tr√™n, t∆∞∆°ng t·ª± tinh th·∫ßn c·ªßa Phase 1 & 2.
H√£y b·∫Øt ƒë·∫ßu v·ªõi stub ƒë·ªÉ ki·ªÉm th·ª≠ nhanh, sau ƒë√≥ thay b·∫±ng model th·∫≠t ƒë·ªÉ ra k·∫øt qu·∫£ cu·ªëi c√πng.
"""


